from Utils import *import timeimport socketimport mathimport sysfrom thread import *import astimport numpy as npimport argparseimport randomfrom one_step import simulateparser = argparse.ArgumentParser()parser.add_argument('-np', '--num-players', dest="num_players", type=int,                    default=1,                    help='1 Player or 2 Player')parser.add_argument('-p', '--port', dest="PORT", type=int,                    default=12121,                    help='Port')parser.add_argument('-rs', '--random-seed', dest="rng", type=int,                    default=0,                    help='Random Seed')parser.add_argument('-c', '--color', dest="color", type=str,                    default="Black",                    help='Legal color to pocket')args = parser.parse_args()host = '127.0.0.1'port = args.PORTrandom.seed(args.rng)# holes =[(22.21,22.21),(22.21,800-22.21),(800-22.21,22.21),# (800-22.21,800-22.21)]holes = [(44.1, 44.1), (755.9, 44.1), (755.9, 755.9), (44.1, 755.9)]def parse_state_message(msg):    s = msg.split(";REWARD")    s[0] = s[0].replace("Vec2d", "")    reward = float(s[1])    state = ast.literal_eval(s[0])    return state, rewarddef get_dist(coins, idx):    distance = 0    for j in range(0, len(coins)):        distance = distance + dist(coins[j], coins[idx])    return distancedef get_coin_min_sep(coins):    maxi_idx = 0    maxi_dist = 100000    dist = 0    for i in range(0, len(coins)):        dist = get_dist(coins, i)        if dist < maxi_dist:            maxi_dist = dist            maxi_idx = i    return maxi_idxdef best_x(coins, tohit, angle_to_hole):    xlist = range(170,640,10)    max_dist = 0    y = 140    x = tohit[0] + (y-tohit[1])*math.tan(angle_to_hole)    if(x < 630 and x > 170):        return x    random.shuffle(xlist)    idx = 0    for i in range(0, len(xlist)):        min_x = min(xlist[i], tohit[0])        max_x = max(xlist[i], tohit[0])        min_y = min(140, tohit[1])        max_y = max(140, tohit[1])        unob_dist = (tohit[0] - xlist[i])*(tohit[0] - xlist[i]) + \                    (tohit[1] - 140)*(tohit[1] - 140)        for j in range(0, len(coins)):            if coins[j][0] >= min_x and coins[j][0] <= max_x and \               coins[j][1] >= min_y and coins[j][1] <= max_y:                distance = dist(coins[j], (xlist[i], 140))                if distance < unob_dist:                    unob_dist = distance        if unob_dist == dist(tohit,(xlist[i],140)):            return xlist[i]        if unob_dist > max_dist :            idx = i            max_dist = unob_dist    return xlist[idx]def best_hole(coin):    maxi_idx = 0    maxi_dist = 0    distance = 0    holes1 = []    for hole in holes:        m = (coin[1]-hole[1])/(coin[0]-hole[0])        c = coin[1]-m*coin[0]        x = (140-c)/m        # del = math.asin(POCKET_RADIUS,dist(hole,coin))/3.14*180        if(170 < x and x < 630):            holes1.append(hole)    if(len(holes1) > 0):        for j in range(0, len(holes1)):            distance = dist(holes1[j], coin)            if distance > maxi_dist:                maxi_dist = distance                maxi_idx = j        return holes1[maxi_idx]    for j in range(0, len(holes)):        distance = dist(holes[j], coin)        if distance > maxi_dist:            maxi_dist = distance            maxi_idx = j    return holes[maxi_idx]def vectorize_state(state):    ans = np.zeros((38))    i = 0    for x in state["White_Locations"]:        ans[i] = x[0]        ans[i+1] = x[1]        i += 2    i = 18    for x in state["Black_Locations"]:        ans[i] = x[0]        ans[i+1] = x[1]        i += 2    i = 36    for x in state["Red_Location"]:        ans[i] = x[0]        ans[i+1] = x[1]    return ansdef play(S):    if len(S["White_Locations"])!=0 or len(S["Black_Locations"])!=0 or len(S["Red_Location"])!=0:        target_list=S["Black_Locations"]+S["Red_Location"] + S["White_Locations"]    if len(target_list) == 2 and len(S["Red_Location"])!=0 :        to_hit = S["Red_Location"][0]    else :        try:            to_hit = target_list[get_coin_min_sep(target_list)]        except:            to_hit = (100,100)    hole = best_hole(to_hit)    angle_to_hole = math.atan2((to_hit[1]-hole[1]),(to_hit[0]-hole[0]))    x = best_x(target_list,to_hit, angle_to_hole)    pos = (x,140)    if(dist(pos,to_hit)<40):        if(x<590):            x+=40        else:            x-=40    pos = (x,140)    angle=math.atan2((to_hit[1]-pos[1]),(to_hit[0]-pos[0]))    if angle < 0:        angle = angle + 2*3.14    angle=angle/3.14*180    if angle>=315 and angle<=360:        angle=angle-360    force =1    if(angle<0 or angle>180):        force = 0.1    angle1=math.atan2((hole[1]-pos[1]),(hole[0]-pos[0]))/3.14*180    # if(abs(angle-angle1)<10):    #     force = 0.1    return str(float(x-170)/float(460))+','+str(angle)+ ','+str(force)def direct_hit(S):    if  len(S["White_Locations"])!=0 or len(S["Black_Locations"])!=0 or len(S["Red_Location"])!=0:        target_list=S["Black_Locations"]+S["Red_Location"] + S["White_Locations"]    if len(target_list) == 2 and len(S["Red_Location"])!=0 :        target_list = S["Red_Location"]    if(len(target_list)>0):        return None    targets=[]    for coin in target_list:        for hole in [(755.9, 755.9), (44.1, 755.9)]:            if(dist(coin,hole)<45):                continue            m=(coin[1]-hole[1])/(coin[0]-hole[0])            c=coin[1]-m*coin[0]            x=(140.0-c)/m            # del=math.asin(POCKET_RADIUS,dist(hole,coin))/3.14*180            ang=math.atan2((coin[1]-140),(coin[0]-x))/3.14*180            if ang < 0:                ang = ang + 360            if ang>=315 and ang<=360:                ang=ang-360            if(170<x and x<630 and ang<=225 and ang>=-45 ):                #find # obstructions                obtr=0                for co in target_list:                    if(dist((x,140),co)<35):                        obtr=10                    if(abs(co[1]-m*co[0]-c)/sqrt(1+m*m) <25):                        obtr+=1                if(obtr<=1):                    targets.append((coin,hole,x,ang,obtr))    min_dist = 10000    idx=0    for i in range(len(targets)):        if(min_dist>dist(targets[i][0],targets[i][1])):            min_dist=dist(targets[i][0],targets[i][1])            idx=i    if(targets!=[]):        print targets[idx]        d=dist((targets[idx][2],140),targets[idx][0])+1.07*dist(targets[idx][0],targets[idx][1])        return str(float(targets[idx][2]-170)/float(460))+','+str(targets[idx][3])+ ','+str(0.002*sqrt(d)*sqrt(targets[idx][4]))    return Nonea_old=Nonefirst = Truedef agent_1player(S):    global a_old, first    flag = 1    # print state    try:        state, reward = parse_state_message(S)  # Get the state and reward    except:        return 0    # Assignment 4: your agent's logic should be coded here    a=direct_hit(state)    if(a==None):        a=play(state)        print "Default"    if(first):        a="1.0, 127.7829, 0.5"        first=False    try:        if(a_old==a):            a="2,-60,0.8"        a_old=a        s.send(a)    except:        print "Error in sending:",  a        print "Closing Connection"        flag = 0    return flagdef agent_2player(state, color):    flag = 1    # Can be ignored for now    a = str(random.random()) + ',' + \        str(random.randrange(-45, 225)) + ',' + str(random.random())    try:        s.send(a)    except Exception as e:        print "Error in sending:",  a, " : ", e        print "Closing connection"        flag = 0    return flagif __name__ == "__main__":    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host, port))    while 1:        state = s.recv(1024)        if agent_1player(state) == 0:            break    s.close()